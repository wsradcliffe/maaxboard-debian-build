#!/bin/bash
# this script will be loaded,and run function[uboot_all_build] when needed
# the "uboot_all_build" name must be fixed.
# if need to define functions,please name "function uboot_[boardname]_*",that avoids overlapping names
#

function do_repo_clone() {
    local remote=$1
    local local_path=$2
    local ret=0

    printf "repo: clone [$remote] to [$local_path] ... "
    git clone "$remote" "$local_path" > /dev/null 2>&1
#    proxychains4 git clone "$remote" "$local_path" > /dev/null 2>&1
    ret=$?
    if [ $ret -eq 0 ]; then
        printf "[OK]\n"
    else
        printf "[FAILED]\n"
    fi

    return $ret
}

function do_repo_checkout() {
    local local_path=$1
    local repo_name=$(basename $local_path)
    local new_branch=
    local ret=0

    if ! [ -d "$local_path" ]; then
        printf "repo: checkout: $local_path do not exist ... [FAILED]\n"
        return 1
    fi

    pushd "$local_path" > /dev/null 2>&1
    new_branch="${config[board]}-${config[tag]}"
    printf "repo[$repo_name]: checkout tag:[${config[tag]}] to new branch:[$new_branch] ... "
    git checkout -b "$new_branch" "${config[tag]}" > /dev/null 2>&1

    ret=$?
    if [ $ret -eq 0 ]; then
        printf "[OK]\n"
    else
        printf "[FAILED]\n"
    fi

    popd > /dev/null 2>&1
    return $ret
}

function do_repo() {
    local remote=$1
    local local_path=$2

    if [ -d "$local_path" ]; then
        printf "repo: $local_path exist, do not need to clone again ...\n"
        return 0
    fi

    if do_repo_clone $remote $local_path; then
        do_repo_checkout $local_path
    fi

    return $?
}

function do_firmware_download() {
    local dir="$IMX_BOOT_PATH"
    local filename="$dir/${config[firmware]}"
    local firmware_d_path="$dir/${config[firmware]%.*}"
    local ret=0

    if [ -e "$filename" ]; then
        printf "firmware: ${config[firmware]} has already downloaded to [$filename]\n"
    else
        printf "firmware: download from [$IMX_FIRMWARE_URL] to [$filename] ... "
        wget -O "$filename" $IMX_FIRMWARE_URL > /dev/null 2>&1
        ret=$?
        if [ $ret -eq 0 ]; then
            printf "[OK]\n"
        else
            printf "[FAILED]\n"
        fi
    fi

    pushd $dir > /dev/null 2>&1

    if [ -d $IMX_FIRMWARE_D_PATH ]; then
        printf "firmware: $(basename $filename) has already decompressed to [$IMX_FIRMWARE_D_PATH]\n"
    else
        printf "firmware: decompress to [$IMX_FIRMWARE_D_PATH]\n"
        sh "${config[firmware]}" --auto-accept --force  > /dev/null 2>&1
    fi

    popd > /dev/null 2>&1
}

function do_mkimage_cp_firmware() {
    local src="$IMX_FIRMWARE_D_PATH"
    local dst="$IMX_MKIMAGE_PATH/$SOC_TARGET"

    mkdir -p $dst

    for ddr_firmware in ${config[ddr]}; do
        printf "firmware: cp ddr: [$ddr_firmware] to [$dst] ... "
        cp "$src/firmware/ddr/synopsys/${ddr_firmware}" "${dst}/"
        printf "[OK]\n"
    done

    printf "firmware: cp: hdmi: [signed_dp_imx8m.bin] to [$dst] ... "
    cp "$src/firmware/hdmi/cadence/signed_dp_imx8m.bin" "${dst}/"
    printf "[OK]\n"

    printf "firmware: cp: hdmi: [signed_hdmi_imx8m.bin] to [$dst] ... "
    cp "$src/firmware/hdmi/cadence/signed_hdmi_imx8m.bin" "${dst}/"
    printf "[OK]\n"
}

function do_uboot_make() {
    local dir="$UBOOT_PATH"

    pushd $dir > /dev/null 2>&1

    printf "uboot: defconfig: [${config[uboot_defconfig]}] ... "
    make "${config[uboot_defconfig]}" > /dev/null 2>&1
    printf "[OK]\n"
    printf "uboot: make ... "
    make -j8 > /dev/null 2>&1

    if [ $? -eq 0 ]; then
        printf "[OK]\n"
    else
        printf "[FAILED]\n"
    fi

    popd > /dev/null 2>&1
}

function do_uboot_clean() {
    local dir="$UBOOT_PATH"

    pushd $dir > /dev/null 2>&1

    printf "uboot: distclean ... "
    make distclean > /dev/null 2>&1

    if [ $? -eq 0 ]; then
        printf "[OK]\n"
    else
        printf "[FAILED]\n"
    fi

    popd > /dev/null 2>&1
}

function do_mkimage_cp_uboot() {
    local src="$UBOOT_PATH"
    local dst="$IMX_MKIMAGE_PATH/$SOC_TARGET"
    local dtb="${config[uboot_dtb]}"
    local dtb_dst="$dst/$PLATFORM-${config[mkimage_board_type]}.dtb"
    local spl_bin_dst="$dst/u-boot-spl-${config[mkimage_ddr_type]}.bin"

    mkdir -p $dst

    cp "$src/arch/arm/dts/$dtb" "$dtb_dst"
    printf "uboot: cp: dtb: [$dtb] to [$dtb_dst] ... [OK]\n"

    cp "$src/spl/u-boot-spl.bin" "$dst/"
    printf "uboot: cp: bin: [spl/u-boot-spl.bin] to [$dst] ... [OK]\n"
#    cp "$src/spl/u-boot-spl.bin" "$spl_bin_dst"
#    printf "uboot: cp: bin: [spl/u-boot-spl.bin] to [$spl_bin_dst] ... [OK]\n"

    cp "$src/u-boot-nodtb.bin" "$dst/"
    printf "uboot: cp: bin: [u-boot-nodtb.bin] to [$dst] ... [OK]\n"

    cp "$src/u-boot.bin" "$dst/"
    printf "uboot: cp: bin: [u-boot.bin] to [$dst] ... [OK]\n"

    cp "$src/tools/mkimage" "$dst/mkimage_uboot"
    printf "uboot: cp: tools: [mkimage] to [$dst/mkimage_uboot] ... [OK]\n"
}

function do_atf_make() {
    local dir="$IMX_ATF_PATH"

    pushd $dir > /dev/null 2>&1


    # Clear LDFLAGS to avoid the option -Wl recognize issue
    unset LDFLAGS

    if [[ -n "${config[cc]}" ]]; then
        printf "imx-atf: make CROSS_COMPILE=${config[cc]} PLAT=${PLATFORM} ... "
        make CROSS_COMPILE="${config[cc]}" PLAT="${PLATFORM}" -j8 > /dev/null 2>&1
    else
        printf "imx-atf: make CROSS_COMPILE=${CROSS_COMPILE} PLAT=${PLATFORM} ... "
        make PLAT="${PLATFORM}" -j8 > /dev/null 2>&1
    fi

    if [ $? -eq 0 ]; then
        printf "[OK]\n"
    else
        printf "[FAILED]\n"
    fi

    popd > /dev/null 2>&1
}

function do_mkimage_cp_atf() {
    local src="$IMX_ATF_PATH/build/imx8mq/release/bl31.bin"
    local dst="$IMX_MKIMAGE_PATH/$SOC_TARGET"

    mkdir -p $dst

    cp "$src" "$dst/"
    printf "imx-atf: cp: bin: [$(basename $src)] to [$dst] ... [OK]\n"
}

function do_mkimage_make() {
    local dir="$IMX_MKIMAGE_PATH"
    local dtb="${config[uboot_dtb]}"
    local target="flash_${config[mkimage_board_type]}"
    local flash_bin_filename="${dir}/${SOC_TARGET}/flash.bin"

    printf "imx-mkimage: make SOC=${SOC_TARGET} DDR_FW_VERSION=${config[ddr_version]} ${target} ... "
    pushd $dir > /dev/null 2>&1

    make clean > /dev/null 2>&1

    make SOC=${SOC_TARGET} DDR_FW_VERSION=${config[ddr_version]} ${target}
#    make SOC=${SOC_TARGET} DDR_FW_VERSION=${config[ddr_version]} ${target} > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        printf "[OK]\n"
    else
        printf "[FAILED]\n"
    fi
    popd > /dev/null 2>&1

    printf "imx-mkimage: flash.bin: generate at [ $flash_bin_filename ] ... [OK]\n"
    printf "dd-example: dd if=flash.bin of=/dev/sda bs=1k seek=${config[seek]} conv=fsync\n"
}

function uboot_maaxboard_mini_code(){
    cd $1
    local tag="lf-5.10.35-2.0.0"
    if [[ -d "./uboot-imx" ]];then
        local count=$(ls uboot-imx/ |wc -w)
        if [[ ${count} > 0 ]];then
            cd uboot-imx
            return 0;
        else
            rm -rf uboot-imx
        fi
    fi
    git clone -b ${tag} --single-branch https://github.com/nxp-imx/uboot-imx.git
    cd uboot-imx
    local VERSION=`grep ^VERSION Makefile | cut -d' ' -f3`
    local PATCHLEVEL=`grep ^PATCHLEVEL Makefile | cut -d' ' -f3`
    local SUBLEVEL=`grep ^SUBLEVEL Makefile | cut -d' ' -f3`
    local branch=`git branch | cut -d' ' -f2`
    local commitid=`git log --oneline -1 | cut -d' ' -f1`
    local uboot_tar="u-boot_${VERSION}.${PATCHLEVEL}.${SUBLEVEL}_${tag}_${commitid}.tar.gz"

    git archive --prefix=u-boot/ -o ../${uboot_tar} HEAD
    mv ../${uboot_tar} $2
}

function uboot_maaxboard_mini_complete(){
    cd ..
    echo "pwd $(pwd)"
    cp -f ./imx-boot/imx-mkimage/iMX8M/flash.bin u-boot.imx
    cp u-boot.imx ../

    log_info "uboot compile finish."
}

# compile uboot
# param $1 : Work directory
# output: ${BASE_ROOT}/u-boot.imx
# output src path ${LINUX_SRC_OUTPUT}
function uboot_all_build(){
    local BASE_ROOT=$1
    local tmp_path=$(pwd)

    typeset -A config
    config=(
        [board]="imx8mq-evk"
        [tag]="lf-5.10.35-2.0.0"
        [firmware]="firmware-imx-8.12.bin"
        [ddr]="lpddr4_pmu_train_1d_imem.bin lpddr4_pmu_train_1d_dmem.bin lpddr4_pmu_train_2d_imem.bin lpddr4_pmu_train_2d_dmem.bin"
        [ddr_version]="_201904"
        [uboot_defconfig]="imx8mq_evk_defconfig"
        [uboot_dtb]="imx8mq-evk.dtb"
        [mkimage_ddr_type]="lpddr4"
        [mkimage_board_type]="evk"
        [seek]="33"
    )

    uboot_maaxboard_mini_code ${BASE_ROOT} ${LINUX_SRC_OUTPUT}

    IMX_FIRMWARE_URL="https://www.nxp.com/lgfiles/NMG/MAD/YOCTO/${config[firmware]}"
    IMX_GIT_REMOTE=https://github.com/nxp-imx
    IMX_MKIMAGE_NAME=imx-mkimage
    IMX_ATF_NAME=imx-atf
    IMX_MKIMAGE_REMOTE_REPO=$IMX_GIT_REMOTE/$IMX_MKIMAGE_NAME
    IMX_ATF_REMOTE_REPO=$IMX_GIT_REMOTE/$IMX_ATF_NAME

    UBOOT_PATH=$(dirname $(realpath $0))
    IMX_BOOT_PATH=$(realpath $UBOOT_PATH/../imx-boot)

    mkdir -p $IMX_BOOT_PATH

    IMX_MKIMAGE_PATH=$(realpath $IMX_BOOT_PATH/$IMX_MKIMAGE_NAME)
    IMX_ATF_PATH=$(realpath $IMX_BOOT_PATH/$IMX_ATF_NAME)
    IMX_FIRMWARE_D_PATH="$IMX_BOOT_PATH/${config[firmware]%.*}"

    PLATFORM="imx8mq"
    SOC_TARGET="iMX8M"

    do_repo "$IMX_MKIMAGE_REMOTE_REPO" "$IMX_MKIMAGE_PATH"
    do_repo "$IMX_ATF_REMOTE_REPO" "$IMX_ATF_PATH"

    do_firmware_download
    do_mkimage_cp_firmware

    do_uboot_make
    do_mkimage_cp_uboot

    do_atf_make
    do_mkimage_cp_atf

    do_mkimage_make

    uboot_maaxboard_mini_complete

    cd ${tmp_path}
}
